#git config --local user.name "NOM"
#git config --local user.email "EMAIL"

#git config --local user.name "NOM"
#git config --local user.email "EMAIL"

import string
import random
import datetime
from random import randrange, uniform

print("                                                                      ")
print("- C A P T A I N  C O D E - ")
print("                                                                      ")
print ("WELCOME_BIENVENUE_歓迎_BONI | DD3 INTELLIGENCE AGENCY | SPECIAL REPORT ")
print("                                                                      ")
print("------------------------------------------------------------------------")

now = datetime.datetime.now()
print ("TIME | ", now)
print("------------------------------------------------------------------------")
#print ("YEAR | ", now.year)
#print ("MONTH | ", now.month)
#print ("DAY | ", now.day)
#print ("TIME | ", now.hour, now.minute, now.second)

#if boncode = int and str(input("ENTER AGENT ID | ")):
password  = "bristow15"
boncode = int and str(input("ENTER AGENT ID | "))

if password == boncode:
    print("AUTORISED ACCESS | ")
elif boncode != password:
    print("ACCESS DENIED | ")
    
#while password == False :
 #   print("ACCESS DENIED | ")
#else:
#        print("AUTORISED ACCESS | ")
#        password 

print("------------------------------------------------------------------------")
plain_text = input("CLASSIFIED MESSAGE | ")
print("------------------------------------------------------------------------")
encrypted_text = ("ENCRYPTON | To copy: ")
for c in plain_text:
    x = ord(c)
    x = x + 12 - 6 + 3 - 4 
    c2 = chr(x)
    encrypted_text = encrypted_text + c2
print(encrypted_text)
print("------------------------------------------------------------------------")
print("                                                                      ")
print("// DD3 INTELLIGENCE DECRYPTON //")
print("                                                                      ")
encrypted_text = input("INSERT ENCRYPTON | ")
print("                                                                      ")
plain_text = ("DECRYPTED MESSAGE | ") 
for c in encrypted_text:
    x = ord(c)
    x = x - 12 + 6 - 3 + 4 
    c2 = chr(x)
    plain_text = plain_text + c2
print("------------------------------------------------------------------------")
print ("ANALYSING... | ")
print("------------------------------------------------------------------------")
print("                                                                      ")
print(plain_text) 
print("------------------------------------------------------------------------")

choix = int(input ("COPY (1) OR DESTROY (2) THIS INTEL? "))

if choix == 1:
    print("                                                                      ")
    print ("THANKS. THIS INTEL AS BEEN CLASSIFIED")
    print("                                                                      ")
    print ("YOUR GENERATED FILE CODE IS: ", random.randrange(52,10000007))
    print("                                                                      ")
    print("*** This message will be destroy in 20 secondes ***") 
    print("                                                                      ")
    print ("// DD3 INTELLIGENCE AGENCY | TONI CAPTAIN INC. | SPECIAL REPORT // ")
    print("                                                                      ")
    StopIteration

#import random
#irand = randrange(1, 9025425)

#r = random.randint(1,1000000000000000000000000) 

roll_again = "yes"
f = int and str(input("DESTROY NOW? | (TAP ENTER): "))
[random.randrange(85) for x in range(12546)]

while roll_again == "yes":
    print("                                                                      ")
    print (random.randrange(5876421358)) 
    print("                                                                      ")
    print("                                                                      ")
    print ("DO NOT DISCONNECT | INTEL DESTRUCTION LOADING ")
    print("                                                                      ")
    print("*** This message will be destroy in 20 secondes ***") 
    print("                                                                      ")
    print ("// DD3 INTELLIGENCE AGENCY | TONI CAPTAIN INC. | SPECIAL REPORT // ")


#git config --local user.name "NOM"
#git config --local user.email "EMAIL"

import string
import random
import datetime
from random import randrange, uniform
import calendar
import time 

print("                                                                      ")
print("-  C A P T A I N  |  C O D E  - ")
print("                                                                      ")
print ("WELCOME_BIENVENUE_歓迎_BONI | DD3 INTELLIGENCE AGENCY | SPECIAL REPORT ")
print("                                                                      ")
print("------------------------------------------------------------------------")

now = datetime.datetime.now()
print ("TIME | ", now)
print("------------------------------------------------------------------------")
print("                                                                      ")
cal = calendar.month(2018, 8)
print(cal)
print("------------------------------------------------------------------------")

password  = "bristow15"
boncode = int and str(input("ENTER AGENT ID | "))

if password == boncode:
    print("AUTORISED ACCESS | ")
elif boncode != password:
    print("ACCESS DENIED | ")

dict = {'NAME': 'Agent Sydney Bristow', 'AGE': 28, 'STATUS': 'Active'}
dict['NAME'] = "Agent Sydney Bristow"; 
dict['AGE'] = 28; 
dict['LAST MISSION'] = "Industrie de la paix (african areas)"; 
dict['STATUS'] = "ACTIVE"; 

print("NAME: ", dict['NAME'])
print("AGE: ", dict['AGE'])
print("LAST MISSION: ", dict['LAST MISSION'])
print("STATUS: ", dict['STATUS'])

print("------------------------------------------------------------------------")
plain_text = input("CLASSIFIED MESSAGE | ")
print("------------------------------------------------------------------------")
encrypted_text = ("ENCRYPTON | To copy: ")
for c in plain_text:
    x = ord(c)
    x = x + 12 - 6 + 3 - 4 
    c2 = chr(x)
    encrypted_text = encrypted_text + c2
print(encrypted_text)
print("------------------------------------------------------------------------")
print("                                                                      ")
print("- C A P T A I N  |  D E C R Y P T O N  - ")
print("                                                                      ")
encrypted_text = input("INSERT ENCRYPTON | ")
print("                                                                      ")
plain_text = ("DECRYPTED MESSAGE | ") 
for c in encrypted_text:
    x = ord(c)
    x = x - 12 + 6 - 3 + 4 
    c2 = chr(x)
    plain_text = plain_text + c2
print("------------------------------------------------------------------------")
print ("ANALYSING... | ")
print("------------------------------------------------------------------------")
print("                                                                      ")
print(plain_text) 
print("------------------------------------------------------------------------")

choix = int(input ("COPY (1) OR DESTROY (2) THIS INTEL? "))

if choix == 1:
    print("                                                                      ")
    print ("THANKS. THIS INTEL AS BEEN CLASSIFIED")
    print("                                                                      ")
    print ("YOUR GENERATED FILE CODE IS: ", random.randrange(52,10000007))
    print("                                                                      ")
    print("*** This message will be destroy in 20 secondes ***") 
    print("                                                                      ")
    print ("// DD3 INTELLIGENCE AGENCY | TONI CAPTAIN INC. | SPECIAL REPORT // ")
    print("                                                                      ")
    StopIteration

roll_again = "yes"
var = "no"
f = int and str(input("DESTROY NOW? | (TAP ENTER): "))

class App:

    def __init__(self, master):

        frame = Frame(master)
        frame.pack()

        self.button = Button(
            frame, text="QUIT", fg="red", command=frame.quit
            )
        self.button.pack(side=LEFT)

root = Tk()

app = App(root)

root.mainloop()
root.destroy() 
[random.randrange(120) for x in range(12546)]

while roll_again == "yes":
    list = [ 'DD3', random.randrange(5458), 9.687, 'captain', random.randrange(108) ]
    tinylist = [random.randrange(5458), 'captain']
    print("                                                                      ")
    print (random.randrange(38768)) 
    OverflowError
    print("                                                                      ")
    print(list[2:])
    print("                                                                      ")
    print(list[1:3])
    print ("DO NOT DISCONNECT | INTEL DESTRUCTION LOADING ")
    print("                                                                      ")
    print(list[0])
    print(" *** This message will be destroy in 30 secondes *** ") 
    print(list + tinylist)
    print("                                                                      ")
    print(list) 
    print ("// DD3 INTELLIGENCE AGENCY | TONI CAPTAIN INC. | SPECIAL REPORT // ")

    var == roll_again 
    print("INTEL AS BEEN DESTROYED")
   

    print("                                                                      ")
    print (random.randrange(5876421358)) 
    print("                                                                      ")
    
    print ("INTEL AS BEEN DESTROYED")
    print("                                                                      ")
    print(" *** This message will be destroy in 30 secondes ***" ) 
    print("                                                                      ")
    print ("// DD3 INTELLIGENCE AGENCY | TONI CAPTAIN INC. | SPECIAL REPORT // ")



#####BOUTON ID
def add():
    a = float(num1In.get("1.0"))
    b = float(num2In.get("1.0"))
    ansOut['text'] = str(a + b)

#defines window
tk = Tkinter.Tk(None)

# creates a frame (a place on which to put components)
frame = Tkinter.Frame(tk, borderwidth=2)

#packs frame to fill window
frame.pack(expand=1)

#defines a label (static text to show purporse of input)
num1Lb = Tkinter.Label(frame, text = "AGENT ID | ")

#places component on a grid (colum span shows how many colums it goes through)
num1Lb.grid(row=0, column=0, columnspan=2)

#defines a text input box (a place to recieve text input)
num1In = Tkinter.Text(frame, height=1, width=31)

#places component on a grid
num1In.grid(row=0, column=2, columnspan=2)

#same as with number 1
num2Lb = Tkinter.Label(frame, text = "PASSWORD | ")
num2Lb.grid(row=1, column=0, columnspan=2)
num2In = Tkinter.Text(frame, height=1, width=31)
num2In.grid(row=1, column=2, columnspan=2)

#defines a button (fommand is function but without brackets)
btnAdd = Tkinter.Button(frame, text="Add", command=add)

#places component on a grid
btnAdd.grid(row=3, column=0, columnspan=1)


#starts window
tk.mainloop()


#####MISE EN PAGE APPLI TEST1
import Tkinter

app= Tkinter.Tk()
frame=Tkinter.Frame(app)
frame.pack()

rightframe=Tkinter.Frame(app,width="300")
rightframe.pack(side="right")

txtLabel=Tkinter.Label(frame,text="- CAPTAIN | CODE - ")
txtLabel.pack()

redbutton = Tkinter.Label(rightframe, text="ENCRYPTON", fg="blue")
redbutton.pack( side = "top")
greenbutton = Tkinter.Label(rightframe, text="DECRYPTON", fg="grey")
greenbutton.pack( side = "top")

leftframe=Tkinter.Frame(app)
leftframe.pack(side="bottom")

redbutton1 = Tkinter.Button(leftframe, text="ENCODE", fg="red")
redbutton1.pack( side = "left")
greenbutton1 = Tkinter.Button(leftframe, text="TARGETS", fg="brown")
greenbutton1.pack( side = "left")
bluebutton1 = Tkinter.Button(leftframe, text="MAPS", fg="blue")
bluebutton1.pack( side = "left" )

app.mainloop()


######MESSAGE LISTING

from Tkinter import *

class INTELLIGENCE_DATA_BASE(Frame):
    def __init__(self, master, lists):
        Frame.__init__(self, master)
        self.lists = []
        for l,w in lists:
            frame = Frame(self); frame.pack(side=LEFT, expand=YES, fill=BOTH)
            Label(frame, text=l, borderwidth=1, relief=RAISED).pack(fill=X)
            lb = Listbox(frame, width=w, borderwidth=0, selectborderwidth=0,
                         relief=FLAT, exportselection=FALSE)
            lb.pack(expand=YES, fill=BOTH)
            self.lists.append(lb)
            lb.bind('<B1-Motion>', lambda e, s=self: s._select(e.y))
            lb.bind('<Button-1>', lambda e, s=self: s._select(e.y))
            lb.bind('<Leave>', lambda e: 'break')
            lb.bind('<B2-Motion>', lambda e, s=self: s._b2motion(e.x, e.y))
            lb.bind('<Button-2>', lambda e, s=self: s._button2(e.x, e.y))
        frame = Frame(self); frame.pack(side=LEFT, fill=Y)
        Label(frame, borderwidth=1, relief=RAISED).pack(fill=X)
        sb = Scrollbar(frame, orient=VERTICAL, command=self._scroll)
        sb.pack(expand=YES, fill=Y)
        self.lists[0]['yscrollcommand']=sb.set

    def _select(self, y):
        row = self.lists[0].nearest(y)
        self.selection_clear(0, END)
        self.selection_set(row)
        return 'break'

    def _button2(self, x, y):
        for l in self.lists: l.scan_mark(x, y)
        return 'break'

    def _b2motion(self, x, y):
        for l in self.lists: l.scan_dragto(x, y)
        return 'break'

    def _scroll(self, *args):
        for l in self.lists:
            apply(l.yview, args)

    def curselection(self):
        return self.lists[0].curselection(  )

    def delete(self, first, last=None):
        for l in self.lists:
            l.delete(first, last)

    def get(self, first, last=None):
        result = []
        for l in self.lists:
            result.append(l.get(first,last))
        if last: return apply(map, [None] + result)
        return result

    def index(self, index):
        self.lists[0].index(index)

    def insert(self, index, *elements):
        for e in elements:
            i = 0
            for l in self.lists:
                l.insert(index, e[i])
                i = i + 1

    def size(self):
        return self.lists[0].size(  )

    def see(self, index):
        for l in self.lists:
            l.see(index)

    def selection_anchor(self, index):
        for l in self.lists:
            l.selection_anchor(index)

    def selection_clear(self, first, last=None):
        for l in self.lists:
            l.selection_clear(first, last)

    def selection_includes(self, index):
        return self.lists[0].selection_includes(index)

    def selection_set(self, first, last=None):
        for l in self.lists:
            l.selection_set(first, last)

if __name__ == '__main__':
    tk = Tk(  )
    Label(tk, text='INTELLIGENCE_DATA_BASE').pack(  )
    mlb = INTELLIGENCE_DATA_BASE(tk, (("CLASSIFIED MESSAGE |", 40), ("AGENT | ", 20), ("DATE | ", 10)))
    for i in range(1000):
      mlb.insert(END, 
          ("CONFIDENTIAL | : %d" % i, 'John Doe', '10/10/%04d' % (1900+i)))
    mlb.pack(expand=YES,fill=BOTH)
tk.mainloop( )


##### COLOR CODE
import Tkinter

FONT = ('helvetica',24,'bold')

def main():
    mainWindow = Tkinter.Tk()
    mainWindow.title("- COLOR CODE - ")
    mainFrame = Tkinter.Frame(mainWindow)
    mainFrame.pack(side=Tkinter.RIGHT, expand=Tkinter.YES, fill=Tkinter.BOTH)
    colorSpace = ColorCanvas(mainWindow)
    redScale   = Tkinter.Scale(mainFrame,orient = Tkinter.HORIZONTAL,from_=0,to=255,relief = Tkinter.RAISED,length=300,sliderlength=20,resolution=1, command=colorSpace.setRed)
    greenScale = Tkinter.Scale(mainFrame,orient = Tkinter.HORIZONTAL,from_=0,to=255,relief = Tkinter.RAISED,length=300,sliderlength=20,resolution=1, command=colorSpace.setGreen)
    blueScale  = Tkinter.Scale(mainFrame,orient = Tkinter.HORIZONTAL,from_=0,to=255,relief = Tkinter.RAISED,length=300,sliderlength=20,resolution=1, command=colorSpace.setBlue)
    redLabel = Tkinter.Label(mainFrame, text="RED |")
    greenLabel = Tkinter.Label(mainFrame, text="GREEN |")
    blueLabel = Tkinter.Label(mainFrame, text="BLUE |")
    colorSpace.addScales(redScale, greenScale, blueScale)
    colorSpace.pack(side=Tkinter.LEFT, fill=Tkinter.BOTH)
    redLabel.pack(side=Tkinter.TOP)
    redScale.pack(side=Tkinter.TOP, expand=Tkinter.YES, fill=Tkinter.Y)
    greenLabel.pack(side=Tkinter.TOP)
    greenScale.pack(side=Tkinter.TOP, expand=Tkinter.YES, fill=Tkinter.Y)
    blueLabel.pack(side=Tkinter.TOP)
    blueScale.pack(side=Tkinter.TOP, expand=Tkinter.YES, fill=Tkinter.Y)
    mainWindow.protocol('WM_DELETE_WINDOW', mainWindow.destroy)
    mainWindow.mainloop()

class ColorCanvas(Tkinter.Canvas):
    def __init__(self, master, *args, **kwargs):
        Tkinter.Canvas.__init__(self, master, *args, **kwargs)
        self.__redScale, self.__greenScale, self.__blueScale = [False] * 3
        self.__t = self.create_text(10, 10, text='', font=FONT, anchor=Tkinter.NW)
        try:
            self.__red   = int(kwargs['background'][1:3], 16)
            self.__green = int(kwargs['background'][3:5], 16)
            self.__blue  = int(kwargs['background'][5:], 16)
        except:
            self.__red, self.__green, self.__blue = [0] * 3

    def addScales(self, redScale, greenScale, blueScale):
        self.__redScale, self.__greenScale, self.__blueScale = redScale, greenScale, blueScale

    def toHex(self, integer):
        if integer < 16:
            return '0%s' % hex(integer)[2:]
        else:
            return '%s' % hex(integer)[2:]

    def showHexColor(self, colorstring):
        if (self.__red + self.__green + self.__blue) / 3 > 128:
            textcolor = '#000000'
        else:
            textcolor = '#ffffff'
        self.itemconfigure(self.__t, text=colorstring, fill=textcolor)

    def setRed(self, event=None):
        if self.__redScale:
            self.__red = self.__redScale.get()
            colorstring = '#%s%s%s' % (self.toHex(self.__red), self.toHex(self.__green), self.toHex(self.__blue))
            self.configure(background=colorstring)
            self.showHexColor(colorstring)

    def setGreen(self, event=None):
        if self.__greenScale:
            self.__green = self.__greenScale.get()
            colorstring = '#%s%s%s' % (self.toHex(self.__red), self.toHex(self.__green), self.toHex(self.__blue))
            self.configure(background=colorstring)
            self.showHexColor(colorstring)

    def setBlue(self, event=None):
        if self.__blueScale:
            self.__blue = self.__blueScale.get()
            colorstring = '#%s%s%s' % (self.toHex(self.__red), self.toHex(self.__green), self.toHex(self.__blue))
            self.configure(background=colorstring)
            self.showHexColor(colorstring)

main()

### ENCODE YOUR SIZE
from Tkinter import *

def printer(event):
    global s # use global StringVar to show the results
    import random

    r_sample = random.sample(range(a.get(), b.get()), c.get())

    # set the s variable with the random sample
    s.set(",".join(map(str,r_sample)))
    return

root = Tk()

s = StringVar()

# IntVars added here
a = IntVar()
b = IntVar()
c = IntVar()

lab = Label(root, text="GARMENT LENGHT", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=a)
lab.pack()
ent.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

lab = Label(root, text="CHEST", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=b)
lab.pack()
ent.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

lab = Label(root, text="SLEEVES", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=c)
lab.pack()
ent.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

lab = Label(root, text="WAIST", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=c)
lab.pack()
ent.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

lab = Label(root, text="NECK", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=c)
lab.pack()
ent.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

lab = Label(root, text="PANT LENGHT", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=c)
lab.pack()
ent.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

but = Button(root, text="MADE BY MEASURE",
             width=20,height=5,
             bg="green",fg="yellow")
but.bind("<Button-1>", printer)
but.pack()

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

separator = Frame(height=2, bd=1, relief=SUNKEN)
separator.pack(fill=X, padx=5, pady=5)

lab = Label(root, text="| YOUR SIZE CODE | ", font="Arial 10")
ent = Entry(root,width=20,bd=3, textvariable=s)
lab.pack()
ent.pack()

root.mainloop()


#### STORY APPAREL
from Tkinter import *           # Importing the Tkinter (tool box) library 
root = Tk()                     # Create a background window
                                # Create a list
print("| STORY APPAREL | ")
li = 'NEWS GADJET CAP JACKETS SWEAT TEE'.split()
listb = Listbox(root)           # Create a listbox widget
for item in li:                 # Insert each item within li into the listbox
    listb.insert(0,item)

listb.pack()                    # Pack listbox widget
root.mainloop()                 # Execute the main event handler


#### ENCODER INPUT
import os
import sys
import fileinput

print ("Text to search for:")
textToSearch = input( "> " ) 

print ("Text to replace it with:")
textToReplace = input( "> " )

print ("File to perform Search-Replace on:")
fileToSearch  = input( "> " )
#fileToSearch = 'D:\dummy1.txt'

tempFile = open( fileToSearch, 'r+' )

for line in fileinput.input( fileToSearch ):
    if textToSearch in line :
        print('Match Found')
    else:
        print('Match Not Found!!')
    tempFile.write( line.replace( textToSearch, textToReplace ) )
tempFile.close()


input( '\n\n Press Enter to exit...' )


#### Afficheur d'heure et date
import Tkinter
import time

class Clock(Tkinter.Label):

    def __init__(self, parent=None, seconds=True, colon=False):
    
        Tkinter.Label.__init__(self, parent)

        self.display_seconds = seconds
        if self.display_seconds:
            self.time     = time.strftime('%H:%M:%S')
        else:
            self.time     = time.strftime('%I:%M %p').lstrip('0')
        self.display_time = self.time
        self.configure(text=self.display_time)

        if colon:
            self.blink_colon()

        self.after(200, self.tick)


    def tick(self):
        if self.display_seconds:
            new_time = time.strftime('%H:%M:%S')
        else:
            new_time = time.strftime('%I:%M %p').lstrip('0')
        if new_time != self.time:
            self.time = new_time
            self.display_time = self.time
            self.config(text=self.display_time)
        self.after(200, self.tick)


    def blink_colon(self):
        """ Blink the colon every second """
        if ':' in self.display_time:
            self.display_time = self.display_time.replace(':',' ')
        else:
            self.display_time = self.display_time.replace(' ',':',1)
        self.config(text=self.display_time)
        self.after(1000, self.blink_colon)

if __name__ == "__main__":

    window = Tkinter.Tk()
    frame  = Tkinter.Frame(window, width=400, height=400 )
    frame.pack()

    Tkinter.Label(frame, text="TIME | ").pack()

    clock1 = Clock(frame)
    clock1.pack()
    clock1.configure(bg='green',fg='yellow',font=("helvetica",35))

    Tkinter.Label(frame, text=" ").pack()

    Tkinter.Label(frame, text="DATE | ").pack()

    clock2 = Clock(frame, seconds=False, colon=True)
    clock2.pack()
    clock2.configure(bg='red',fg='white',font=("arial",20))

    Tkinter.Label(frame, text=" ").pack()

    Tkinter.Label(frame, text="| DD3 INTELLIGENCE AGENCY 2018 | ").pack()

window.mainloop()


#### CREATE FORMES
from Tkinter import *

master = Tk()

w = Canvas(master, width=1080, height=920)
w.pack()

w.create_line(0, 10, 246, 365)
w.create_line(0, 100, 200, 0, fill="red", dash=(4, 4))

w.create_rectangle(100, 1523, 256, 96, fill="blue")
w.create_rectangle(256, 1756, 966, 34, fill="black")

mainloop()

### FOND COURLEUR DERRIERE TYPO
from Tkinter import *

root = Tk()

w = Label(root, text="Red", bg="red", fg="white")
w.pack(side=LEFT)
w = Label(root, text="Green", bg="green", fg="black")
w.pack(side=LEFT)
w = Label(root, text="Blue", bg="blue", fg="white")
w.pack(side=LEFT)

mainloop()


### BOUTON QUI FONCTIONNE
from Tkinter import *

root = Tk()

#def callback():
   # print "called the callback!"

# create a toolbar
toolbar = Frame(root)

b = Button(toolbar, text="new", width=6, command=callback)
b.pack(side=LEFT, padx=2, pady=2)

b = Button(toolbar, text="open", width=6, command=callback)
b.pack(side=LEFT, padx=2, pady=2)

toolbar.pack(side=TOP, fill=X)

mainloop()


### LOGIN PARFAIT
from Tkinter import *

class MyDialog:

    def __init__(self, parent):

        top = self.top = Toplevel(parent)

        Label(top, text="Value").pack()

        self.e = Entry(top)
        self.e.pack(padx=5)

        b = Button(top, text="OK", command=self.ok)
        b.pack(pady=5)

    def ok(self):

        print "value is", self.e.get()

        self.top.destroy()


root = Tk()
Button(root, text="Hello!").pack()
root.update()

d = MyDialog(root)

root.wait_window(d.top)

### ANALYSE DE FRAPPE
from Tkinter import *

root = Tk()

def key(event):
    print "pressed", repr(event.char)

def callback(event):
    frame.focus_set()
    print "clicked at", event.x, event.y

frame = Frame(root, width=1080, height=920)
frame.bind("<Key>", key)
frame.bind("<Button-1>", callback)
frame.pack()

print("- DD3 AGENCY | SPY TAPER - ") 

mainloop()


### MENU CHOISIR SA COULEUR TOP
from Tkinter import *
from tkColorChooser import askcolor                  

def callback():
    result = askcolor(color="#6A9662", 
                      title = "Bernd's Colour Chooser") 
    print result
    
root = Tk()
Button(root, 
       text='Choose Color', 
       fg="darkgreen", 
       command=callback).pack(side=LEFT, padx=10)
Button(text='Quit', 
       command=root.quit,
       fg="red").pack(side=LEFT, padx=10)
mainloop()


### CAPTAIN PAINT
from Tkinter import *

canvas_width = 500
canvas_height = 150

def paint( event ):
   python_green = "#476042"
   x1, y1 = ( event.x - 1 ), ( event.y - 1 )
   x2, y2 = ( event.x + 1 ), ( event.y + 1 )
   w.create_oval( x1, y1, x2, y2, fill = python_green )

master = Tk()
master.title( "- CAPTAIN | PAINT - " )
w = Canvas(master, 
           width=canvas_width, 
           height=canvas_height)
w.pack(expand = YES, fill = BOTH)
w.bind( "<B1-Motion>", paint )

message = Label( master, text = "Press & Drag the mouse to draw" )
message.pack( side = BOTTOM )
    
mainloop()

### BITMAP
from Tkinter import *

canvas_width = 2000
canvas_height =1000

master = Tk()
canvas = Canvas(master, 
           width=canvas_width, 
           height=canvas_height)
canvas.pack()

bitmaps = ["error", "gray75", "gray50", "gray25", "gray12", "hourglass", "info", "questhead", "question", "warning"]
nsteps = len(bitmaps)
step_x = int(canvas_width / nsteps)

for i in range(0, nsteps):
   canvas.create_bitmap((i+1)*step_x - step_x/2,50, bitmap=bitmaps[i])

mainloop()

### SELECT A COUNTRY GLOBAL INTEL
import Tkinter as tk

root = tk.Tk()

v = tk.IntVar()
v.set(1)  # initializing the choice, i.e. Python

languages = [
    ("FRANCE"),
    ("BELGIUM"),
    ("USA"),
    ("CHINA"),
    ("RDC")
]

def ShowChoice():
    print(v.get())

tk.Label(root, 
         text="""| DD3 GLOBAL INTELLIGENCE |
    SELECT A COUNTRY:""",
         justify = tk.LEFT,
         padx = 20).pack()

for val, language in enumerate(languages):
    tk.Radiobutton(root, 
                  text=language,
                  padx = 20, 
                  variable=v, 
                  command=ShowChoice,
                  value=val).pack(anchor=tk.W)


root.mainloop()



#### COMPTEUR / MINUTEUR
import Tkinter as tk

counter = 0 
def counter_label(label):
  def count():
    global counter
    counter += 1
    label.config(text=str(counter))
    label.after(5000, count)
  count()
 
 
root = tk.Tk()
root.title("Counting Seconds")
label = tk.Label(root, fg="blue")
label.pack()
counter_label(label)
button = tk.Button(root, text='Stop', width=25, command=root.destroy)
button.pack()
root.mainloop()


### SHOP YOUR CLOTHE / COCHER CASE
class Checkbar(Frame):
   def __init__(self, parent=None, picks=[], side=LEFT, anchor=W):
      Frame.__init__(self, parent)
      self.vars = []
      for pick in picks:
         var = IntVar()
         chk = Checkbutton(self, text=pick, variable=var)
         chk.pack(side=side, anchor=anchor, expand=YES)
         self.vars.append(var)
   def state(self):
      return map((lambda var: var.get()), self.vars)
if __name__ == '__main__':
   root = Tk()
   lng = Checkbar(root, ['Python', 'Ruby', 'Perl', 'C++'])
   tgl = Checkbar(root, ['English','German'])
   lng.pack(side=TOP,  fill=X)
   tgl.pack(side=LEFT)
   lng.config(relief=GROOVE, bd=2)

   def allstates(): 
      print(list(lng.state()), list(tgl.state()))
   Button(root, text='Quit', command=root.quit).pack(side=RIGHT)
   Button(root, text='Peek', command=allstates).pack(side=RIGHT)
   root.mainloop()

# COCHER et MONTRER deux cases
   from Tkinter import *

master = Tk()

def var_states():
   print("male: %d,\nfemale: %d" % (var1.get(), var2.get()))

Label(master, text="Your sex:").grid(row=0, sticky=W)
var1 = IntVar()
Checkbutton(master, text="male", variable=var1).grid(row=1, sticky=W)
var2 = IntVar()
Checkbutton(master, text="female", variable=var2).grid(row=2, sticky=W)
Button(master, text='Quit', command=master.quit).grid(row=3, sticky=W, pady=4)
Button(master, text='Show', command=var_states).grid(row=4, sticky=W, pady=4)
mainloop()



### FORMULAIRE / LOGGIN ID PARFAIT
from Tkinter import *

fields = 'Last Name', 'First Name', 'Job', 'Country'

def fetch(entries):
   for entry in entries:
      field = entry[0]
      text  = entry[1].get()
      print('%s: "%s"' % (field, text)) 

def makeform(root, fields):
   entries = []
   for field in fields:
      row = Frame(root)
      lab = Label(row, width=15, text=field, anchor='w')
      ent = Entry(row)
      row.pack(side=TOP, fill=X, padx=5, pady=5)
      lab.pack(side=LEFT)
      ent.pack(side=RIGHT, expand=YES, fill=X)
      entries.append((field, ent))
   return entries

if __name__ == '__main__':
   root = Tk()
   ents = makeform(root, fields)
   root.bind('<Return>', (lambda event, e=ents: fetch(e)))   
   b1 = Button(root, text='Show',
          command=(lambda e=ents: fetch(e)))
   b1.pack(side=LEFT, padx=5, pady=5)
   b2 = Button(root, text='Quit', command=root.quit)
   b2.pack(side=LEFT, padx=5, pady=5)
   root.mainloop()

   ### FORMULE
   from Tkinter import *

fields = ('Annual Rate', 'Number of Payments', 'Loan Principle', 'Monthly Payment', 'Remaining Loan')

def monthly_payment(entries):
   # period rate:
   r = (float(entries['Annual Rate'].get()) / 100) / 12
   print("r", r)
   # principal loan:
   loan = float(entries['Loan Principle'].get())
   n =  float(entries['Number of Payments'].get())
   remaining_loan = float(entries['Remaining Loan'].get())
   q = (1 + r)** n
   monthly = r * ( (q * loan - remaining_loan) / ( q - 1 ))
   monthly = ("%8.2f" % monthly).strip()
   entries['Monthly Payment'].delete(0,END)
   entries['Monthly Payment'].insert(0, monthly )
   print("Monthly Payment: %f" % float(monthly))

def final_balance(entries):
   # period rate:
   r = (float(entries['Annual Rate'].get()) / 100) / 12
   print("r", r)
   # principal loan:
   loan = float(entries['Loan Principle'].get())
   n =  float(entries['Number of Payments'].get()) 
   q = (1 + r)** n
   monthly = float(entries['Monthly Payment'].get())
   q = (1 + r)** n
   remaining = q * loan  - ( (q - 1) / r) * monthly
   remaining = ("%8.2f" % remaining).strip()
   entries['Remaining Loan'].delete(0,END)
   entries['Remaining Loan'].insert(0, remaining )
   print("Remaining Loan: %f" % float(remaining))

def makeform(root, fields):
   entries = {}
   for field in fields:
      row = Frame(root)
      lab = Label(row, width=22, text=field+": ", anchor='w')
      ent = Entry(row)
      ent.insert(0,"0")
      row.pack(side=TOP, fill=X, padx=5, pady=5)
      lab.pack(side=LEFT)
      ent.pack(side=RIGHT, expand=YES, fill=X)
      entries[field] = ent
   return entries

if __name__ == '__main__':
   root = Tk()
   ents = makeform(root, fields)
   root.bind('<Return>', (lambda event, e=ents: fetch(e)))   
   b1 = Button(root, text='Final Balance',
          command=(lambda e=ents: final_balance(e)))
   b1.pack(side=LEFT, padx=5, pady=5)
   b2 = Button(root, text='Monthly Payment',
          command=(lambda e=ents: monthly_payment(e)))
   b2.pack(side=LEFT, padx=5, pady=5)
   b3 = Button(root, text='Quit', command=root.quit)
   b3.pack(side=LEFT, padx=5, pady=5)
   root.mainloop()


### SLIDER / MAP
from Tkinter import *

def show_values():
    print (w1.get(), w2.get())

master = Tk()
w1 = Scale(master, from_=0, to=100, tickinterval=8)
w1.set(19256)
w1.pack()
w2 = Scale(master, from_=0, to=200, length=920,tickinterval=10, orient=HORIZONTAL) 
w2.set(232153)
w2.pack()
Button(master, text='Show', command=show_values).pack()


mainloop()


### CAPTAIN NOTEPAD ° IMAGE (A METTRE)
from Tkinter import *

root = Tk()

text1 = Text(root, height=20, width=30)
text1.insert(END,'\n')

text1.pack(side=LEFT)

text2 = Text(root, height=20, width=50)
scroll = Scrollbar(root, command=text2.yview)
text2.configure(yscrollcommand=scroll.set)
text2.tag_configure('bold_italics', font=('Arial', 12, 'bold', 'italic'))
text2.tag_configure('big', font=('Verdana', 20, 'bold'))
text2.tag_configure('color', foreground='#476042', 
						font=('Tempus Sans ITC', 12, 'bold'))
text2.tag_bind('follow', '<1>', lambda e, t=text2: t.insert(END, "Not now, maybe later!"))
text2.insert(END,'\nINTELLIGENCE NOTES |\n', 'big')
quote = """
Put your intel
"""
text2.insert(END, quote, 'color')
text2.pack(side=LEFT)
scroll.pack(side=RIGHT, fill=Y)

root.mainloop()


# NOTEPAD Avec IMAGE
from Tkinter import *

root = Tk()

text1 = Text(root, height=20, width=30)
photo=PhotoImage(file='./William_Shakespeare.gif')
text1.insert(END,'\n')
text1.image_create(END, image=photo)

text1.pack(side=LEFT)

text2 = Text(root, height=20, width=50)
scroll = Scrollbar(root, command=text2.yview)
text2.configure(yscrollcommand=scroll.set)
text2.tag_configure('bold_italics', font=('Arial', 12, 'bold', 'italic'))
text2.tag_configure('big', font=('Verdana', 20, 'bold'))
text2.tag_configure('color', foreground='#476042', 
						font=('Tempus Sans ITC', 12, 'bold'))
text2.tag_bind('follow', '<1>', lambda e, t=text2: t.insert(END, "Not now, maybe later!"))
text2.insert(END,'\nWilliam Shakespeare\n', 'big')
quote = """
To be, or not to be that is the question:
Whether 'tis Nobler in the mind to suffer
The Slings and Arrows of outrageous Fortune,
Or to take Arms against a Sea of troubles,
"""
text2.insert(END, quote, 'color')
text2.insert(END, 'follow-up\n', 'follow')
text2.pack(side=LEFT)
scroll.pack(side=RIGHT, fill=Y)

root.mainloop()

### FENETRE MESSAGE QUIT? 
from Tkinter import *
from tkMessageBox import *

def answer():
    showerror("Answer", "Sorry, no answer available")

def callback():
    if askyesno('Verify', 'Really quit?'):
        showwarning('Yes', 'Not yet implemented')
    else:
        showinfo('No', 'Quit has been cancelled')

Button(text='Quit', command=callback).pack(fill=X)
Button(text='Answer', command=answer).pack(fill=X)
mainloop()

### IMPORTER UN DOCUMENT
from Tkinter import *
from tkFileDialog   import askopenfilename      

def callback():
    name= askopenfilename() 
    print name
    
errmsg = 'Error!'
Button(text='Import', command=callback).pack(fill=X)
mainloop()


### MOUSE TRACKING / MAP
from Tkinter import *

def motion(event):
  print("Mouse position: (%s %s)" % (event.x, event.y))

master = Tk()
msg = Message(master, text = "| DD3 INTELLIGENCE AGNECY | ")
msg.config(bg='lightblue', font=('helvetica', 200, 'bold'))
msg.bind('<Motion>',motion)
msg.pack()
mainloop()


### WELCOME AGENT
def hi(obj):
    print("WELCOME AGENT " + obj.name + "!")

class Robot:
    pass
    

x = Robot()
x.name = "Marvin"
hi(x)

### LIGHT GRAPHICS
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np
from numpy.random import multivariate_normal

data = np.vstack([
    multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),
    multivariate_normal([30, 20], [[2, 3], [1, 3]], size=100000)
])

gammas = [0.8, 0.5, 0.3]

fig, axes = plt.subplots(nrows=2, ncols=2)

axes[0, 0].set_title('Linear normalization')
axes[0, 0].hist2d(data[:, 0], data[:, 1], bins=100)

for ax, gamma in zip(axes.flat[1:], gammas):
    ax.set_title('Power law $(\gamma=%1.1f)$' % gamma)

fig.tight_layout()

plt.show()

### GRAPHICS CHIMIE
import numpy as np

import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.spines import Spine
from matplotlib.projections.polar import PolarAxes
from matplotlib.projections import register_projection


def radar_factory(num_vars, frame='circle'):
    """Create a radar chart with `num_vars` axes.

    This function creates a RadarAxes projection and registers it.

    Parameters
    ----------
    num_vars : int
        Number of variables for radar chart.
    frame : {'circle' | 'polygon'}
        Shape of frame surrounding axes.

    """
    # calculate evenly-spaced axis angles
    theta = np.linspace(0, 2*np.pi, num_vars, endpoint=False)

    def draw_poly_patch(self):
        # rotate theta such that the first axis is at the top
        verts = unit_poly_verts(theta + np.pi / 2)
        return plt.Polygon(verts, closed=True, edgecolor='k')

    def draw_circle_patch(self):
        # unit circle centered on (0.5, 0.5)
        return plt.Circle((0.5, 0.5), 0.5)

    patch_dict = {'polygon': draw_poly_patch, 'circle': draw_circle_patch}
    if frame not in patch_dict:
        raise ValueError('unknown value for `frame`: %s' % frame)

    class RadarAxes(PolarAxes):

        name = 'radar'
        # use 1 line segment to connect specified points
        RESOLUTION = 1
        # define draw_frame method
        draw_patch = patch_dict[frame]

        def __init__(self, *args, **kwargs):
            super(RadarAxes, self).__init__(*args, **kwargs)
            # rotate plot such that the first axis is at the top
            self.set_theta_zero_location('N')

        def fill(self, *args, **kwargs):
            """Override fill so that line is closed by default"""
            closed = kwargs.pop('closed', True)
            return super(RadarAxes, self).fill(closed=closed, *args, **kwargs)

        def plot(self, *args, **kwargs):
            """Override plot so that line is closed by default"""
            lines = super(RadarAxes, self).plot(*args, **kwargs)
            for line in lines:
                self._close_line(line)

        def _close_line(self, line):
            x, y = line.get_data()
            # FIXME: markers at x[0], y[0] get doubled-up
            if x[0] != x[-1]:
                x = np.concatenate((x, [x[0]]))
                y = np.concatenate((y, [y[0]]))
                line.set_data(x, y)

        def set_varlabels(self, labels):
            self.set_thetagrids(np.degrees(theta), labels)

        def _gen_axes_patch(self):
            return self.draw_patch()

        def _gen_axes_spines(self):
            if frame == 'circle':
                return PolarAxes._gen_axes_spines(self)
            # The following is a hack to get the spines (i.e. the axes frame)
            # to draw correctly for a polygon frame.

            # spine_type must be 'left', 'right', 'top', 'bottom', or `circle`.
            spine_type = 'circle'
            verts = unit_poly_verts(theta + np.pi / 2)
            # close off polygon by repeating first vertex
            verts.append(verts[0])
            path = Path(verts)

            spine = Spine(self, spine_type, path)
            spine.set_transform(self.transAxes)
            return {'polar': spine}

    register_projection(RadarAxes)
    return theta


def unit_poly_verts(theta):
    """Return vertices of polygon for subplot axes.

    This polygon is circumscribed by a unit circle centered at (0.5, 0.5)
    """
    x0, y0, r = [0.5] * 3
    verts = [(r*np.cos(t) + x0, r*np.sin(t) + y0) for t in theta]
    return verts


def example_data():
    # The following data is from the Denver Aerosol Sources and Health study.
    # See  doi:10.1016/j.atmosenv.2008.12.017
    #
    # The data are pollution source profile estimates for five modeled
    # pollution sources (e.g., cars, wood-burning, etc) that emit 7-9 chemical
    # species. The radar charts are experimented with here to see if we can
    # nicely visualize how the modeled source profiles change across four
    # scenarios:
    #  1) No gas-phase species present, just seven particulate counts on
    #     Sulfate
    #     Nitrate
    #     Elemental Carbon (EC)
    #     Organic Carbon fraction 1 (OC)
    #     Organic Carbon fraction 2 (OC2)
    #     Organic Carbon fraction 3 (OC3)
    #     Pyrolized Organic Carbon (OP)
    #  2)Inclusion of gas-phase specie carbon monoxide (CO)
    #  3)Inclusion of gas-phase specie ozone (O3).
    #  4)Inclusion of both gas-phase species is present...
    data = [
        ['Sulfate', 'Nitrate', 'EC', 'OC1', 'OC2', 'OC3', 'OP', 'CO', 'O3'],
        ('Basecase', [
            [0.88, 0.15, 0.03, 0.03, 0.00, 0.06, 0.01, 0.00, 0.00],
            [0.07, 0.95, 0.04, 0.69, 0.00, 0.02, 0.01, 0.00, 0.00],
            [0.01, 0.02, 0.85, 0.19, 0.05, 0.10, 0.00, 0.00, 0.00],
            [0.02, 0.01, 0.07, 0.01, 0.21, 0.56, 0.98, 0.00, 0.00],
            [0.01, 0.01, 0.02, 0.71, 0.74, 0.70, 0.00, 0.00, 0.00]]),
        ('With CO', [
            [0.88, 0.02, 0.02, 0.02, 0.45, 0.05, 0.00, 0.05, 0.00],
            [0.08, 0.94, 0.04, 0.02, 0.00, 0.01, 0.12, 0.04, 0.00],
            [0.01, 0.01, 0.79, 0.10, 0.00, 0.05, 0.00, 0.31, 0.00],
            [0.00, 0.02, 0.03, 0.38, 0.31, 0.31, 0.00, 0.59, 0.00],
            [0.02, 0.02, 0.11, 0.47, 0.69, 0.58, 0.88, 0.00, 0.00]]),
        ('With O3', [
            [0.89, 0.01, 0.07, 0.00, 0.00, 0.05, 0.00, 0.00, 0.03],
            [0.07, 0.95, 0.05, 0.04, 0.00, 0.02, 0.12, 0.00, 0.00],
            [0.01, 0.02, 0.86, 0.27, 0.16, 0.19, 0.00, 0.00, 0.00],
            [0.01, 0.03, 0.00, 0.32, 0.29, 0.27, 0.00, 0.00, 0.95],
            [0.02, 0.00, 0.03, 0.37, 0.56, 0.47, 0.87, 0.00, 0.00]]),
        ('CO & O3', [
            [0.87, 0.01, 0.08, 0.00, 0.00, 0.04, 0.00, 0.00, 0.01],
            [0.09, 0.95, 0.02, 0.03, 0.00, 0.01, 0.13, 0.06, 0.00],
            [0.01, 0.02, 0.71, 0.24, 0.13, 0.16, 0.00, 0.50, 0.00],
            [0.01, 0.03, 0.00, 0.28, 0.24, 0.23, 0.00, 0.44, 0.88],
            [0.02, 0.00, 0.18, 0.45, 0.64, 0.55, 0.86, 0.00, 0.16]])
    ]
    return data


if __name__ == '__main__':
    N = 9
    theta = radar_factory(N, frame='polygon')

    data = example_data()
    spoke_labels = data.pop(0)

    fig, axes = plt.subplots(figsize=(9, 9), nrows=2, ncols=2,
                             subplot_kw=dict(projection='radar'))
    fig.subplots_adjust(wspace=0.25, hspace=0.20, top=0.85, bottom=0.05)

    colors = ['b', 'r', 'g', 'm', 'y']
    # Plot the four cases from the example data on separate axes
    for ax, (title, case_data) in zip(axes.flatten(), data):
        ax.set_rgrids([0.2, 0.4, 0.6, 0.8])
        ax.set_title(title, weight='bold', size='medium', position=(0.5, 1.1),
                     horizontalalignment='center', verticalalignment='center')
        for d, color in zip(case_data, colors):
            ax.plot(theta, d, color=color)
            ax.fill(theta, d, facecolor=color, alpha=0.25)
        ax.set_varlabels(spoke_labels)

    # add legend relative to top-left plot
    ax = axes[0, 0]
    labels = ('Factor 1', 'Factor 2', 'Factor 3', 'Factor 4', 'Factor 5')
    legend = ax.legend(labels, loc=(0.9, .95),
                       labelspacing=0.1, fontsize='small')

    fig.text(0.5, 0.965, '| CAPTAIN GRAPH CHEMESTRY |',
             horizontalalignment='center', color='black', weight='bold',
             size='large')

    plt.show()



### CAPTAIN LOCALISATION / LATTITUDE LONGITUDE
import matplotlib.pyplot as plt

plt.figure()
plt.subplot(111, projection="lambert")
plt.title("| OPERATIONS MAP |")
plt.grid(True)
plt.figure()
plt.subplot(111, projection="mollweide")
plt.title("| OPERATIONS MAP |Mollweide")
plt.grid(True)

# CUSTOM LONGITUDE...
from __future__ import unicode_literals

import matplotlib
from matplotlib.axes import Axes
from matplotlib.patches import Circle
from matplotlib.path import Path
from matplotlib.ticker import NullLocator, Formatter, FixedLocator
from matplotlib.transforms import Affine2D, BboxTransformTo, Transform
from matplotlib.projections import register_projection
import matplotlib.spines as mspines
import matplotlib.axis as maxis
import numpy as np

rcParams = matplotlib.rcParams

# This example projection class is rather long, but it is designed to
# illustrate many features, not all of which will be used every time.
# It is also common to factor out a lot of these methods into common
# code used by a number of projections with similar characteristics
# (see geo.py).


class GeoAxes(Axes):
    """
    An abstract base class for geographic projections
    """
    class ThetaFormatter(Formatter):
        """
        Used to format the theta tick labels.  Converts the native
        unit of radians into degrees and adds a degree symbol.
        """
        def __init__(self, round_to=1.0):
            self._round_to = round_to

        def __call__(self, x, pos=None):
            degrees = np.round(np.rad2deg(x) / self._round_to) * self._round_to
            if rcParams['text.usetex'] and not rcParams['text.latex.unicode']:
                return r"$%0.0f^\circ$" % degrees
            else:
                return "%0.0f\N{DEGREE SIGN}" % degrees

    RESOLUTION = 75

    def _init_axis(self):
        self.xaxis = maxis.XAxis(self)
        self.yaxis = maxis.YAxis(self)
        # Do not register xaxis or yaxis with spines -- as done in
        # Axes._init_axis() -- until GeoAxes.xaxis.cla() works.
        # self.spines['geo'].register_axis(self.yaxis)
        self._update_transScale()

    def cla(self):
        Axes.cla(self)

        self.set_longitude_grid(30)
        self.set_latitude_grid(15)
        self.set_longitude_grid_ends(75)
        self.xaxis.set_minor_locator(NullLocator())
        self.yaxis.set_minor_locator(NullLocator())
        self.xaxis.set_ticks_position('none')
        self.yaxis.set_ticks_position('none')
        self.yaxis.set_tick_params(label1On=True)
        # Why do we need to turn on yaxis tick labels, but
        # xaxis tick labels are already on?

        self.grid(rcParams['axes.grid'])

        Axes.set_xlim(self, -np.pi, np.pi)
        Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)

    def _set_lim_and_transforms(self):
        # A (possibly non-linear) projection on the (already scaled) data

        # There are three important coordinate spaces going on here:
        #
        #    1. Data space: The space of the data itself
        #
        #    2. Axes space: The unit rectangle (0, 0) to (1, 1)
        #       covering the entire plot area.
        #
        #    3. Display space: The coordinates of the resulting image,
        #       often in pixels or dpi/inch.

        # This function makes heavy use of the Transform classes in
        # ``lib/matplotlib/transforms.py.`` For more information, see
        # the inline documentation there.

        # The goal of the first two transformations is to get from the
        # data space (in this case longitude and latitude) to axes
        # space.  It is separated into a non-affine and affine part so
        # that the non-affine part does not have to be recomputed when
        # a simple affine change to the figure has been made (such as
        # resizing the window or changing the dpi).

        # 1) The core transformation from data space into
        # rectilinear space defined in the HammerTransform class.
        self.transProjection = self._get_core_transform(self.RESOLUTION)

        # 2) The above has an output range that is not in the unit
        # rectangle, so scale and translate it so it fits correctly
        # within the axes.  The peculiar calculations of xscale and
        # yscale are specific to a Aitoff-Hammer projection, so don't
        # worry about them too much.
        self.transAffine = self._get_affine_transform()

        # 3) This is the transformation from axes space to display
        # space.
        self.transAxes = BboxTransformTo(self.bbox)

        # Now put these 3 transforms together -- from data all the way
        # to display coordinates.  Using the '+' operator, these
        # transforms will be applied "in order".  The transforms are
        # automatically simplified, if possible, by the underlying
        # transformation framework.
        self.transData = \
            self.transProjection + \
            self.transAffine + \
            self.transAxes

        # The main data transformation is set up.  Now deal with
        # gridlines and tick labels.

        # Longitude gridlines and ticklabels.  The input to these
        # transforms are in display space in x and axes space in y.
        # Therefore, the input values will be in range (-xmin, 0),
        # (xmax, 1).  The goal of these transforms is to go from that
        # space to display space.  The tick labels will be offset 4
        # pixels from the equator.
        self._xaxis_pretransform = \
            Affine2D() \
            .scale(1.0, self._longitude_cap * 2.0) \
            .translate(0.0, -self._longitude_cap)
        self._xaxis_transform = \
            self._xaxis_pretransform + \
            self.transData
        self._xaxis_text1_transform = \
            Affine2D().scale(1.0, 0.0) + \
            self.transData + \
            Affine2D().translate(0.0, 4.0)
        self._xaxis_text2_transform = \
            Affine2D().scale(1.0, 0.0) + \
            self.transData + \
            Affine2D().translate(0.0, -4.0)

        # Now set up the transforms for the latitude ticks.  The input to
        # these transforms are in axes space in x and display space in
        # y.  Therefore, the input values will be in range (0, -ymin),
        # (1, ymax).  The goal of these transforms is to go from that
        # space to display space.  The tick labels will be offset 4
        # pixels from the edge of the axes ellipse.
        yaxis_stretch = Affine2D().scale(np.pi*2, 1).translate(-np.pi, 0)
        yaxis_space = Affine2D().scale(1.0, 1.1)
        self._yaxis_transform = \
            yaxis_stretch + \
            self.transData
        yaxis_text_base = \
            yaxis_stretch + \
            self.transProjection + \
            (yaxis_space +
             self.transAffine +
             self.transAxes)
        self._yaxis_text1_transform = \
            yaxis_text_base + \
            Affine2D().translate(-8.0, 0.0)
        self._yaxis_text2_transform = \
            yaxis_text_base + \
            Affine2D().translate(8.0, 0.0)

    def _get_affine_transform(self):
        transform = self._get_core_transform(1)
        xscale, _ = transform.transform_point((np.pi, 0))
        _, yscale = transform.transform_point((0, np.pi / 2.0))
        return Affine2D() \
            .scale(0.5 / xscale, 0.5 / yscale) \
            .translate(0.5, 0.5)

    def get_xaxis_transform(self, which='grid'):
        """
        Override this method to provide a transformation for the
        x-axis tick labels.

        Returns a tuple of the form (transform, valign, halign)
        """
        if which not in ['tick1', 'tick2', 'grid']:
            raise ValueError(
                "'which' must be one of 'tick1', 'tick2', or 'grid'")
        return self._xaxis_transform

    def get_xaxis_text1_transform(self, pad):
        return self._xaxis_text1_transform, 'bottom', 'center'

    def get_xaxis_text2_transform(self, pad):
        """
        Override this method to provide a transformation for the
        secondary x-axis tick labels.

        Returns a tuple of the form (transform, valign, halign)
        """
        return self._xaxis_text2_transform, 'top', 'center'

    def get_yaxis_transform(self, which='grid'):
        """
        Override this method to provide a transformation for the
        y-axis grid and ticks.
        """
        if which not in ['tick1', 'tick2', 'grid']:
            raise ValueError(
                "'which' must be one of 'tick1', 'tick2', or 'grid'")
        return self._yaxis_transform

    def get_yaxis_text1_transform(self, pad):
        """
        Override this method to provide a transformation for the
        y-axis tick labels.

        Returns a tuple of the form (transform, valign, halign)
        """
        return self._yaxis_text1_transform, 'center', 'right'

    def get_yaxis_text2_transform(self, pad):
        """
        Override this method to provide a transformation for the
        secondary y-axis tick labels.

        Returns a tuple of the form (transform, valign, halign)
        """
        return self._yaxis_text2_transform, 'center', 'left'

    def _gen_axes_patch(self):
        """
        Override this method to define the shape that is used for the
        background of the plot.  It should be a subclass of Patch.

        In this case, it is a Circle (that may be warped by the axes
        transform into an ellipse).  Any data and gridlines will be
        clipped to this shape.
        """
        return Circle((0.5, 0.5), 0.5)

    def _gen_axes_spines(self):
        return {'geo': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}

    def set_yscale(self, *args, **kwargs):
        if args[0] != 'linear':
            raise NotImplementedError

    # Prevent the user from applying scales to one or both of the
    # axes.  In this particular case, scaling the axes wouldn't make
    # sense, so we don't allow it.
    set_xscale = set_yscale

    # Prevent the user from changing the axes limits.  In our case, we
    # want to display the whole sphere all the time, so we override
    # set_xlim and set_ylim to ignore any input.  This also applies to
    # interactive panning and zooming in the GUI interfaces.
    def set_xlim(self, *args, **kwargs):
        raise TypeError("It is not possible to change axes limits "
                        "for geographic projections. Please consider "
                        "using Basemap or Cartopy.")

    set_ylim = set_xlim

    def format_coord(self, lon, lat):
        """
        Override this method to change how the values are displayed in
        the status bar.

        In this case, we want them to be displayed in degrees N/S/E/W.
        """
        lon, lat = np.rad2deg([lon, lat])
        if lat >= 0.0:
            ns = 'N'
        else:
            ns = 'S'
        if lon >= 0.0:
            ew = 'E'
        else:
            ew = 'W'
        return ('%f\N{DEGREE SIGN}%s, %f\N{DEGREE SIGN}%s'
                % (abs(lat), ns, abs(lon), ew))

    def set_longitude_grid(self, degrees):
        """
        Set the number of degrees between each longitude grid.

        This is an example method that is specific to this projection
        class -- it provides a more convenient interface to set the
        ticking than set_xticks would.
        """
        # Skip -180 and 180, which are the fixed limits.
        grid = np.arange(-180 + degrees, 180, degrees)
        self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))
        self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))

    def set_latitude_grid(self, degrees):
        """
        Set the number of degrees between each longitude grid.

        This is an example method that is specific to this projection
        class -- it provides a more convenient interface than
        set_yticks would.
        """
        # Skip -90 and 90, which are the fixed limits.
        grid = np.arange(-90 + degrees, 90, degrees)
        self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))
        self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))

    def set_longitude_grid_ends(self, degrees):
        """
        Set the latitude(s) at which to stop drawing the longitude grids.

        Often, in geographic projections, you wouldn't want to draw
        longitude gridlines near the poles.  This allows the user to
        specify the degree at which to stop drawing longitude grids.

        This is an example method that is specific to this projection
        class -- it provides an interface to something that has no
        analogy in the base Axes class.
        """
        self._longitude_cap = np.deg2rad(degrees)
        self._xaxis_pretransform \
            .clear() \
            .scale(1.0, self._longitude_cap * 2.0) \
            .translate(0.0, -self._longitude_cap)

    def get_data_ratio(self):
        """
        Return the aspect ratio of the data itself.

        This method should be overridden by any Axes that have a
        fixed data ratio.
        """
        return 1.0

    # Interactive panning and zooming is not supported with this projection,
    # so we override all of the following methods to disable it.
    def can_zoom(self):
        """
        Return *True* if this axes supports the zoom box button functionality.
        This axes object does not support interactive zoom box.
        """
        return False

    def can_pan(self):
        """
        Return *True* if this axes supports the pan/zoom button functionality.
        This axes object does not support interactive pan/zoom.
        """
        return False

    def start_pan(self, x, y, button):
        pass

    def end_pan(self):
        pass

    def drag_pan(self, button, key, x, y):
        pass


class HammerAxes(GeoAxes):
    """
    A custom class for the Aitoff-Hammer projection, an equal-area map
    projection.

    https://en.wikipedia.org/wiki/Hammer_projection
    """

    # The projection must specify a name. This will be used by the
    # user to select the projection,
    # i.e. ``subplot(111, projection='custom_hammer')``.
    name = 'custom_hammer'

    class HammerTransform(Transform):
        """
        The base Hammer transform.
        """
        input_dims = 2
        output_dims = 2
        is_separable = False

        def __init__(self, resolution):
            """
            Create a new Hammer transform.  Resolution is the number of steps
            to interpolate between each input line segment to approximate its
            path in curved Hammer space.
            """
            Transform.__init__(self)
            self._resolution = resolution

        def transform_non_affine(self, ll):
            longitude = ll[:, 0:1]
            latitude = ll[:, 1:2]

            # Pre-compute some values
            half_long = longitude / 2.0
            cos_latitude = np.cos(latitude)
            sqrt2 = np.sqrt(2.0)

            alpha = np.sqrt(1.0 + cos_latitude * np.cos(half_long))
            x = (2.0 * sqrt2) * (cos_latitude * np.sin(half_long)) / alpha
            y = (sqrt2 * np.sin(latitude)) / alpha
            return np.concatenate((x, y), 1)
        transform_non_affine.__doc__ = Transform.transform_non_affine.__doc__

        def transform_path_non_affine(self, path):
            # vertices = path.vertices
            ipath = path.interpolated(self._resolution)
            return Path(self.transform(ipath.vertices), ipath.codes)
        transform_path_non_affine.__doc__ = \
            Transform.transform_path_non_affine.__doc__

        def inverted(self):
            return HammerAxes.InvertedHammerTransform(self._resolution)
        inverted.__doc__ = Transform.inverted.__doc__

    class InvertedHammerTransform(Transform):
        input_dims = 2
        output_dims = 2
        is_separable = False

        def __init__(self, resolution):
            Transform.__init__(self)
            self._resolution = resolution

        def transform_non_affine(self, xy):
            x, y = xy.T
            z = np.sqrt(1 - (x / 4) ** 2 - (y / 2) ** 2)
            longitude = 2 * np.arctan((z * x) / (2 * (2 * z ** 2 - 1)))
            latitude = np.arcsin(y*z)
            return np.column_stack([longitude, latitude])
        transform_non_affine.__doc__ = Transform.transform_non_affine.__doc__

        def inverted(self):
            return HammerAxes.HammerTransform(self._resolution)
        inverted.__doc__ = Transform.inverted.__doc__

    def __init__(self, *args, **kwargs):
        self._longitude_cap = np.pi / 2.0
        GeoAxes.__init__(self, *args, **kwargs)
        self.set_aspect(0.5, adjustable='box', anchor='C')
        self.cla()

    def _get_core_transform(self, resolution):
        return self.HammerTransform(resolution)


# Now register the projection with matplotlib so the user can select
# it.
register_projection(HammerAxes)


if __name__ == '__main__':
    import matplotlib.pyplot as plt
    # Now make a simple example using the custom projection.
    plt.subplot(111, projection="custom_hammer")
    p = plt.plot([-1, 1, 1], [-1, -1, 1], "o-")
    plt.grid(True)

    plt.show()
    

plt.show()

### ROND IMAGE
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.cbook as cbook


with cbook.get_sample_data('grace_hopper.png') as image_file:
    image = plt.imread(image_file)

fig, ax = plt.subplots()
im = ax.imshow(image)
patch = patches.Circle((260, 200), radius=200, transform=ax.transData)
im.set_clip_path(patch)

ax.axis('off')
plt.show()

### TRIANGULATION
import matplotlib.tri as tri
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np


#-----------------------------------------------------------------------------
# Analytical test function
#-----------------------------------------------------------------------------
def function_z(x, y):
    """ A function of 2 variables """
    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)
    theta1 = np.arctan2(0.5 - x, 0.5 - y)
    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)
    theta2 = np.arctan2(-x - 0.2, -y - 0.2)
    z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +
          (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +
          0.7 * (x**2 + y**2))
    return (np.max(z) - z) / (np.max(z) - np.min(z))

#-----------------------------------------------------------------------------
# Creating a Triangulation
#-----------------------------------------------------------------------------
# First create the x and y coordinates of the points.
n_angles = 135
n_radii = 7
min_radius = 0.35
radii = np.linspace(min_radius, 0.56, n_radii)

angles = np.linspace(0, 4 * np.pi, n_angles, endpoint=False)
angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
angles[:, 1::2] += np.pi / n_angles

x = (radii * np.cos(angles)).flatten()
y = (radii * np.sin(angles)).flatten()
z = function_z(x, y)

# Now create the Triangulation.
# (Creating a Triangulation without specifying the triangles results in the
# Delaunay triangulation of the points.)
triang = tri.Triangulation(x, y)

# Mask off unwanted triangles.
triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
                         y[triang.triangles].mean(axis=1))
                < min_radius)

#-----------------------------------------------------------------------------
# Refine data
#-----------------------------------------------------------------------------
refiner = tri.UniformTriRefiner(triang)
tri_refi, z_test_refi = refiner.refine_field(z, subdiv=3)

#-----------------------------------------------------------------------------
# Plot the triangulation and the high-res iso-contours
#-----------------------------------------------------------------------------
plt.figure()
plt.gca().set_aspect('equal')
plt.triplot(triang, lw=0.5, color='white')

levels = np.arange(0., 1., 0.056)
cmap = cm.get_cmap(name='terrain', lut=None)
plt.tricontourf(tri_refi, z_test_refi, levels=levels, cmap=cmap)
plt.tricontour(tri_refi, z_test_refi, levels=levels,
               colors=['0.25', '0.5', '0.5', '0.5', '0.5'],
               linewidths=[1.0, 0.5, 0.5, 0.5, 0.5])

plt.title("- D D 3  I N T E L I G E N C E  A G E N C Y | HD Tricontouring - ")

plt.show()

### POLAR AXIS 
import numpy as np
import matplotlib.pyplot as plt


# Fixing random state for reproducibility
np.random.seed(19680801)

# Compute areas and colors
N = 150
r = 2 * np.random.rand(N)
theta = 2 * np.pi * np.random.rand(N)
area = 200 * r**2
colors = theta

fig = plt.figure()
ax = fig.add_subplot(111, projection='polar')
c = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)

plt.show()

### WAVE DETECTOR
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Fixing random state for reproducibility
np.random.seed(19680801)


# Create new Figure with black background
fig = plt.figure(figsize=(8, 8), facecolor='black')

# Add a subplot with no frame
ax = plt.subplot(111, frameon=False)

# Generate random data
data = np.random.uniform(0, 1, (64, 75))
X = np.linspace(-1, 1, data.shape[-1])
G = 1.5 * np.exp(-4 * X ** 2)

# Generate line plots
lines = []
for i in range(len(data)):
    # Small reduction of the X extents to get a cheap perspective effect
    xscale = 1 - i / 200.
    # Same for linewidth (thicker strokes on bottom)
    lw = 1.5 - i / 100.0
    line, = ax.plot(xscale * X, i + G * data[i], color="w", lw=lw)
    lines.append(line)

# Set y limit (or first line is cropped because of thickness)
ax.set_ylim(-1, 70)

# No ticks
ax.set_xticks([])
ax.set_yticks([])

lines = []
for i in range(len(data)):
    # Small reduction of the X extents to get a cheap perspective effect
    xscale = 1 - i / 200.
    # Same for linewidth (thicker strokes on bottom)
    lw = 1.5 - i / 100.0
    line, = ax.plot(xscale * X, i + G * data[i], color="w", lw=lw)
    lines.append(line)

# Set y limit (or first line is cropped because of thickness)
ax.set_ylim(-1, 70)

# No ticks
ax.set_xticks([])
ax.set_yticks([])

# 2 part titles to get different font weights
ax.text(0.5, 1.0, "DD3 INTELIGENCE AGENCY | ", transform=ax.transAxes,
        ha="right", va="bottom", color="w",
        family="sans-serif", fontweight="light", fontsize=16)
ax.text(0.5, 1.0, "WAVE DETECTOR PROGRAM", transform=ax.transAxes,
        ha="left", va="bottom", color="w",
        family="sans-serif", fontweight="bold", fontsize=16)


def update(*args):
    # Shift all data to the right
    data[:, 1:] = data[:, :-1]

    # Fill-in new values
    data[:, 0] = np.random.uniform(0, 1, len(data))

    # Update data
    for i in range(len(data)):
        lines[i].set_ydata(i + G * data[i])

    # Return modified artists
    return lines

# Construct the animation, using the update function as the animation director.
anim = animation.FuncAnimation(fig, update, interval=10)
plt.show()


### GENERATE QR CODE / SQUARE cODE
import numpy as np
import matplotlib.pyplot as plt


def hinton(matrix, max_weight=None, ax=None):
    """Draw Hinton diagram for visualizing a weight matrix."""
    ax = ax if ax is not None else plt.gca()

    if not max_weight:
        max_weight = 2 ** np.ceil(np.log(np.abs(matrix).max()) / np.log(2))

    ax.patch.set_facecolor('gray')
    ax.set_aspect('equal', 'box')
    ax.xaxis.set_major_locator(plt.NullLocator())
    ax.yaxis.set_major_locator(plt.NullLocator())

    for (x, y), w in np.ndenumerate(matrix):
        color = 'white' if w > 0 else 'black'
        size = np.sqrt(np.abs(w) / max_weight)
        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,
                             facecolor=color, edgecolor=color)
        ax.add_patch(rect)

    ax.autoscale_view()
    ax.invert_yaxis()


if __name__ == '__main__':
    # Fixing random state for reproducibility
    np.random.seed(143652033)

    hinton(np.random.rand(20, 20) - 0.5)
    plt.show()

### MULTI PENDULUM (cool)
import random as r
import matplotlib.pyplot as plt
from numpy import arange, sin, cos, exp, pi
plt.rcParams["figure.figsize"] = 8,6    # size of plot in inches
 
mf = npend = 4          # # of pendulums & maximum frequency
sigma = 0.005           # frequency spread (from integer)
step = 0.01             # step size
steps = 40000           # # of steps
linew = 2               # line width
def xprint(name, value):    # convenience function to print params.
    print(name+' '.join(['%.4f' % x for x in value]))
 
t = arange(steps)*step      # time axis
d = 1 - arange(steps)/steps # decay vector
while True:
    n = input("Number of pendulums (%d)(0=exit): "%npend)
    if n != '': npend = int(n)
    if npend == 0: break
    n = input("Deviation from integer freq.(%f): "%sigma)
    if n != '': sigma = float(n)
    ax = [r.uniform(0, 1) for i in range(npend)]
    ay = [r.uniform(0, 1) for i in range(npend)]
    px = [r.uniform(0, 2*pi) for i in range(npend)]
    py = [r.uniform(0, 2*pi) for i in range(npend)]
    fx = [r.randint(1, mf) + r.gauss(0, sigma) for i in range(npend)]
    fy = [r.randint(1, mf) + r.gauss(0, sigma) for i in range(npend)]
    xprint('ax = ', ax); xprint('fx = ', fx); xprint('px = ', px)
    xprint('ay = ', ay); xprint('fy = ', fy); xprint('py = ', py)
    x = y = 0
    for i in range(npend):
        x += d * (ax[i] * sin(t * fx[i] + px[i]))
        y += d * (ay[i] * sin(t * fy[i] + py[i]))
    plt.figure(facecolor = 'white')
    plt.plot(x, y, 'k', linewidth=1.5)
    plt.axis('off')
    plt.subplots_adjust(left=0.0, right=1.0, top=1.0, bottom=0.0)
    plt.show(block=False)

    ### CALCULATOR

import Tkinter as tk
from functools import partial
 
def call_result(label_result, n1, n2):
    num1 = (n1.get())
    num2 = (n2.get())
    result = int(num1)*int(num2)
    label_result.config(text="Result is %d" % result)
    return
 
root = tk.Tk()
root.geometry('400x200+100+200')
root.title('- DD3 INTELLIGENCE | Calculator -')
 
number1 = tk.StringVar()
number2 = tk.StringVar()
 
labelTitle = tk.Label(root, text="EQUATION").grid(row=0, column=2)
labelNum1 = tk.Label(root, text="Enter a number").grid(row=1, column=0)
labelNum2 = tk.Label(root, text="Enter another number").grid(row=2, column=0)
labelResult = tk.Label(root)
labelResult.grid(row=7, column=2)

entryNum1 = tk.Entry(root, textvariable=number1).grid(row=1, column=2)
entryNum2 = tk.Entry(root, textvariable=number2).grid(row=2, column=2)
call_result = partial(call_result, labelResult, number1, number2)
buttonCal = tk.Button(root, text="Calculate", command=call_result).grid(row=3, column=0)
root.mainloop()

### CONVERTISSEUR DOMAIN TO IP
import Tkinter as tk
import socket
from functools import partial
 
 
# the main conversion
def call_convert(rlabel1, inputn):
    try:
        ip = (socket.gethostbyname(inputn.get()))
        rlabel1.config(text="The IP address of domain " + inputn.get() + " is " + ip)
    except Exception:
        rlabel1.config(text="Please enter a valid url and in the form 'www.example.com'")
    return
 
 
# app window configuration and UI
root = tk.Tk()
 
# Gets the requested values of the height and width.
windowWidth = root.winfo_reqwidth()
windowHeight = root.winfo_reqheight()
 
# Gets both half the screen width/height and window width/height
positionRight = int(root.winfo_screenwidth() / 2 - windowWidth / 2)
positionDown = int(root.winfo_screenheight() / 2 - windowHeight / 2)
 
root.geometry("600x200+{}+{}".format(positionRight, positionDown))
root.title('- DD3 INTELLIGENCE AGENCY | Domain to IP Converter -  ')
root.configure(background='#0B0B3B')
root.resizable(width=False, height=False)
root.rowconfigure(0, weight=1)
root.columnconfigure(0, weight=1)
root.rowconfigure(2, weight=1)
root.columnconfigure(2, weight=1)
 
contents = tk.Frame(root)
contents.grid(row=1, column=1)
 
domainInput = tk.StringVar()

# label and entry field
input_label = tk.Label(root, text="Enter domain", background='#0B0B3B', foreground="#FFFFFF")
input_entry = tk.Entry(root, textvariable=domainInput)
input_label.grid(row=1)
input_entry.grid(row=1, column=1)
 
# result label's for showing the IP of a domain
result_label1 = tk.Label(root, background='#0B0B3B', foreground="#FFFFFF")
result_label1.grid(row=3, columnspan=4)
 
# button click
call_convert = partial(call_convert, result_label1, domainInput)
result_button = tk.Button(root, text="Convert", command=call_convert, background='#FFFFFF', foreground="#009688")
result_button.grid(row=2, columnspan=4)
 
root.mainloop()

### T° converter à perso
import Tkinter as tk
from functools import partial
 
# global variable
tempVal = "Celsius"
 
 
# getting drop down value
def store_temp(sel_temp):
    global tempVal
    tempVal = sel_temp
 
 
# the main conversion
def call_convert(rlabel1, rlabe12, inputn):
    tem = inputn.get()
    if tempVal == 'Celsius':
        f = float((float(tem) * 9 / 5) + 32)
        k = float((float(tem) + 273.15))
        rlabel1.config(text="%f Fahrenheit" % f)
        rlabe12.config(text="%f Kelvin" % k)
    if tempVal == 'Fahrenheit':
        c = float((float(tem) - 32) * 5 / 9)
        k = c + 273
        rlabel1.config(text="%f Celsius" % c)
        rlabe12.config(text="%f Kelvin" % k)
    if tempVal == 'Kelvin':
        c = float((float(tem) - 273.15))
        f = float((float(tem) - 273.15) * 1.8000 + 32.00)
        rlabel1.config(text="%f Celsius" % c)
        rlabe12.config(text="%f Fahrenheit" % f)
    return
 
 
# app window configuration and UI
root = tk.Tk()
root.geometry('400x150+100+200')
root.title('Temperature Converter')
root.configure(background='#09A3BA')
root.resizable(width=False, height=False)
root.grid_columnconfigure(1, weight=1)
root.grid_rowconfigure(0, weight=1)
 
numberInput = tk.StringVar()
var = tk.StringVar()
 
# label and entry field
input_label = tk.Label(root, text="Enter temperature", background='#09A3BA', foreground="#FFFFFF")
input_entry = tk.Entry(root, textvariable=numberInput)
input_label.grid(row=1)
input_entry.grid(row=1, column=1)
 
# result label's for showing the other two temperatures
result_label1 = tk.Label(root, background='#09A3BA', foreground="#FFFFFF")
result_label1.grid(row=3, columnspan=4)
result_label2 = tk.Label(root, background='#09A3BA', foreground="#FFFFFF")
result_label2.grid(row=4, columnspan=4)
 
# drop down initalization and setup
dropDownList = ["Celsius", "Fahrenheit", "Kelvin"]
dropdown = tk.OptionMenu(root, var, *dropDownList, command=store_temp)
var.set(dropDownList[0])
dropdown.grid(row=1, column=3)
dropdown.config(background='#09A3BA', foreground="#FFFFFF")
dropdown["menu"].config(background='#09A3BA', foreground="#FFFFFF")
 
# button click
call_convert = partial(call_convert, result_label1, result_label2, numberInput)
result_button = tk.Button(root, text="Convert", command=call_convert, background='#09A3BA', foreground="#FFFFFF")
result_button.grid(row=2, columnspan=4)
 
root.mainloop()

### CREER UNE PAGE AVEC TEXT ET BOUTONS

from Tkinter import *
 
root = Tk()
topFrame = Frame(root)
topFrame.pack(side=TOP)
 
middleFrame = Frame(root)
middleFrame.pack(side=RIGHT)
 
bottomFrame = Frame(root, bg="green")
bottomFrame.pack(side=BOTTOM)
 
topFrame_Label = Label(topFrame, text="Welcome to Python GUI(Top Frame)")
topFrame_Label.pack()
 
middleFrame_Label = Label(middleFrame, text="Welcome to Python GUI(Middle Frame)")
middleFrame_Label.pack()
 
bottomFrame_Label = Label(bottomFrame, text="Welcome to Python GUI(Bottom Frame)")
bottomFrame_Label.pack()
theButton = Button(bottomFrame, text="Button", fg="red", bg="black")
theButton.pack()
root.minsize(400, 400)
root.mainloop()


### FIBONACI CALCULATOR
def fibonacci(n):
    if n == 1:
        return 1
    elif n == 0:
        return 0 
    else:
        return fibonacci(n-1) + fibonacci(n-2)
 
number = int(input("Enter an integer: \t"))
for i in range(number):
    print(fibonacci(i))

### Triangulation
b = float(input('Enter base of a triangle: '))
h = float(input('Enter height of a triangle: '))
 
area = (b * h) / 2
print('The area of the triangle is %0.2f' % area)

### RACINE CARRE
num = float(input('Enter a number: '))
 
sqrt = num ** 0.5
print('The square root of %0.3f is %0.3f' % (num, sqrt))

### CREER UN ALGORITMH
def insertion_sort(sort_list):
    for i in range(1, len(sort_list)):
        key = sort_list[i]
        j = i - 1
        while j >= 0 and key < sort_list[j]:
            sort_list[j + 1] = sort_list[j]
            j -= 1
        sort_list[j + 1] = key
    print('\nThe sorted list: \t', sort_list)
    print('\n')
 
 
lst = []
size = int(input("\nEnter size of the list: \t"))
 
for i in range(size):
    elements = int(input("Enter the element: \t"))
    lst.append(elem120ents)
 
insertion_sort(lst)

# AUTRE ALGO
def merge_sort(sort_list):
    print("splitting", sort_list)
    if len(sort_list) > 1:
        mid = len(sort_list) // 2
        leftHalf = sort_list[:mid]
        rightHalf = sort_list[mid:]
 
        merge_sort(leftHalf)
        merge_sort(rightHalf)
 
        i = 0
        j = 0
        k = 0
        while i < len(leftHalf) and j < len(rightHalf):
            if leftHalf[i] < rightHalf[j]:
                sort_list[k] = leftHalf[i]
                i = i + 1
            else:
                sort_list[k] = rightHalf[j]
                j = j + 1
            k = k + 1
 
        while i < len(leftHalf):
            sort_list[k] = leftHalf[i]
            i = i + 1
            k = k + 1
 
        while j < len(rightHalf):
            sort_list[k] = rightHalf[j]
            j = j + 1
            k = k + 1
    print("merging...", sort_list)
 
 
lst = []
size = int(input("Enter size of the list: \t"))
 
for i in range(size):
    elements = int(input("Enter an element: \t"))
    lst.append(elements)
 
merge_sort(lst)

### BOLEEN / SEARcH UNION IN LISTS
lst = []
num = int(input("Enter size of list 1: \t"))
for n in range(num):
    numbers = int(input("Enter any number: \t"))
    lst.append(numbers)
 
lst2 = []
num2 = int(input("Enter size of list 2: \t"))
for n in range(num2):
    numbers2 = int(input("Enter any number: \t"))
    lst2.append(numbers2)
 
union = list(set().union(lst, lst2))
 
print("\nThe Union of two lists is \t", union)

### SOME ELEMENTS LIST / BOUTONS cALCULATRICE
lst = []
num = int(input('How many numbers: '))
for n in range(num):
    numbers = int(input('Enter number '))
    lst.append(numbers)
print("Sum of elements in given list is :", sum(lst))


### LE PLUS GRAND ET PLUS PETIT LIST
number1 = int(input('Enter First number : '))
number2 = int(input('Enter Second number : '))
number3 = int(input('Enter Third number : '))
 
lst = [number1, number2, number3]
 
print("The largest of the 3 numbers is : ", max(lst))
print("The smallest of the 3 numbers is : ", min(lst))

### SINUS GRAPH
from Tkinter import *
import math

root = Tk()
root.title("DD3 | COSMIC WAVES ANALYTICS ")

width = 1080
height = 920
center = height//2
x_increment = 1
# width stretch
x_factor = 1080
# height stretch
y_amplitude = 135

c = Canvas(width=width, height=height, bg='white')
c.pack()

str1 = "sin(x)=INTRCNTNTL"
c.create_text(152, 36, anchor=SW, text=str1)

center_line = c.create_line(0, center, width, center, fill='grey')

# create the coordinate list for the sin() curve, have to be integers
xy1 = []
for x in range(400):
    # x coordinates
    xy1.append(x * x_increment)
    # y coordinates
    xy1.append(int(math.sin(x * x_factor) * y_amplitude) + center)

sin_line = c.create_line(xy1, fill='blue')
root.mainloop()

##### COOL LIEN: https://likegeeks.com/python-gui-examples-tkinter-tutorial/#Create-your-first-GUI-application


### CHOSSE YOUR MODEL
from Tkinter import *

window = Tk()

window.title("Welcome to LikeGeeks app")

window.geometry('350x200')

spin = Spinbox(window, from_=0, to=100, width=5)

spin.grid(column=0,row=0)

window.mainloop()


